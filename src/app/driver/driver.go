package main

import (
	"app/slack"
	"log"
	"strings"
	"time"

	"github.com/SlyMarbo/rss"
)

const url = "https://nvd.nist.gov/download/nvd-rss-analyzed.xml"

var fetcher = rss.Fetch

func main() {
	webhookURL := slack.GetWebhookURL()
	if webhookURL == "" {
		log.Fatal("SLACK_WEBHOOK_URL is not set")
	}
	c := slack.NewClient(webhookURL)

	items, err := getFilteredItems(url)
	if err != nil {
		log.Fatal(err)
	}

	for _, item := range items {
		c.Post(item.SlackPayload())
	}
}

var want = map[string]string{
	"php": "PHP",
}

func getFilteredItems(url string) ([]Item, error) {
	feed, err := fetcher(url)
	if err != nil {
		return nil, err
	}

	var items []Item

	for _, item := range feed.Items {
		items = append(items, filterItem(item)...)
	}

	return items, nil
}

type Item struct {
	CVE     string    `json:"cve"`
	Product string    `json:"product"`
	Summary string    `json:"summary"`
	Link    string    `json:"link"`
	Date    time.Time `json:"date"`
}

func (i Item) SlackPayload() *slack.Payload {
	return &slack.Payload{
		Username: i.CVE,
		Attachments: []*slack.Attachment{
			{
				Pretext: i.Summary,
				Field: []slack.Field{
					{Title: "Product", Value: i.Product, Short: true},
					{Title: "Link", Value: i.Link, Short: true},
				},
				TimeStamp: i.Date.Unix(),
			},
		},
	}
}
func filterItem(item *rss.Item) []Item {
	title := item.Title

	space := strings.IndexByte(title, '(')
	openParent := strings.IndexByte(title, '(')
	closeParent := strings.IndexByte(title, ')')
	if closeParent <= openParent {
		// Something like )(.
		return nil
	}

	products := strings.Split(title[openParent+1:closeParent], ", ")

	var items []Item
	for _, product := range products {
		if p, ok := want[product]; ok {
			items = append(items, Item{
				CVE:     title[:space],
				Product: p,
				Summary: item.Summary,
				Link:    item.Link,
				Date:    item.Date,
			})
		}
	}

	return items
}
