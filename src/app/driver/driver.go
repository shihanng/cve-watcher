package driver

import (
	"app/cvestore"
	"app/slack"
	"log"
	"net/http"
	"strings"

	"appengine/urlfetch"

	"appengine"

	"github.com/SlyMarbo/rss"
)

const url = "https://nvd.nist.gov/download/nvd-rss-analyzed.xml"

var fetcher = rss.FetchByClient

func init() {
	http.HandleFunc("/readfeed", handler)
}

func handler(w http.ResponseWriter, r *http.Request) {
	webhookURL := slack.GetWebhookURL()
	if webhookURL == "" {
		msg := "SLACK_WEBHOOK_URL is not set"
		log.Print(msg)
		http.Error(w, msg, http.StatusInternalServerError)
		return
	}

	ctx := appengine.NewContext(r)

	items, err := getFilteredItems(ctx, url)
	if err != nil {
		log.Print(err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	sc := slack.NewClient(ctx, webhookURL)
	var errPost error
	for _, item := range items {
		if err := sc.Post(item.SlackPayload()); err != nil {
			log.Print(err)
			errPost = err
			continue
		}
	}

	if errPost != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
}

var want = map[string]string{
	"php": "PHP",
}

func getFilteredItems(ctx appengine.Context, url string) ([]cvestore.Item, error) {
	feed, err := fetcher(url, urlfetch.Client(ctx))
	if err != nil {
		return nil, err
	}

	var items []cvestore.Item

	for _, item := range feed.Items {
		items = append(items, filterItem(item)...)
	}

	return items, nil
}

func filterItem(item *rss.Item) []cvestore.Item {
	title := item.Title

	space := strings.IndexByte(title, '(')
	openParent := strings.IndexByte(title, '(')
	closeParent := strings.IndexByte(title, ')')
	if closeParent <= openParent {
		// Something like )(.
		return nil
	}

	products := strings.Split(title[openParent+1:closeParent], ", ")

	var items []cvestore.Item
	for _, product := range products {
		if p, ok := want[product]; ok {
			items = append(items, cvestore.Item{
				CVE:     title[:space],
				Product: p,
				Summary: item.Summary,
				Link:    item.Link,
				Date:    item.Date,
			})
		}
	}

	return items
}
